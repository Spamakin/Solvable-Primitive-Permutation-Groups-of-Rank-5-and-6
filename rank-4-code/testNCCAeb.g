################################################################################
# Possible q, m, p, k combinations that we need to test for B_R case:
# q^m = 2^1 in all cases
# (a) d = 4, p^k = 3^1, 5^1, or 7^1
# (b) d = 6, p^k = 3^1
# (c) d = 10, p^k = 3^1
################################################################################
q := 2; # r
m := 1; # e
d := 4; # d/a
b := d/(q^m); # d/(ea) - Should be greater than 1 for the B_R case
Etype := "-"; # "+" for E+, "-" for E-

for pk in [[7,1]] do
  p := pk[1];
  k := pk[2];
  Print("\n", "q = ", q, ", m = ", m, ", p = ", p, ", k = ", k, ", d = ", d, "\n");

  GLe := GL(q^m,p^k);
  GLb := GL(b,p^k);
  GLeb := GL(q^m*b,p^k);
  perme := IsomorphismPermGroup(GLe);
  permb := IsomorphismPermGroup(GLb);
  permeb := IsomorphismPermGroup(GLeb);
  GLePerm := Image(perme,GLe);
  GLbPerm := Image(permb,GLb);
  GLebPerm := Image(permeb,GLeb);

  # Find the extraspecial subgroup of GL(q^m,p^k)
  GLeSubgroups := List(ConjugacyClassesSubgroups(SylowSubgroup(GLePerm,q)), Representative);
  Extraspecial := ExtraspecialGroup(q^(2*m+1), Etype);
  GLeSubgroups := Filtered(GLeSubgroups,x->Order(x) = Order(Extraspecial));
  GLeSubgroups := Filtered(GLeSubgroups,x->IdGroup(x) = IdGroup(Extraspecial));
  Ex := GLeSubgroups[1];
  # Calculate its normalizer in GL(q^m,p^k)
  NCCA := PreImage(perme, Normalizer(GLePerm, Ex));

  # Embed NCCA into GL(q^m*b,p^k)
  GLeGens := GeneratorsOfGroup(GLe);
  GLebGens := [];
  for GLeGen in GLeGens do
       Append(GLebGens, [KroneckerProduct(GLeGen, IdentityMat(b,GF(p^k)))]);
  od;
  embedding := GroupHomomorphismByImages(GLe, GLeb, GLeGens, GLebGens);
  NCCAeb := Image(embedding, NCCA);
  # Embed CA into GL(q^m*b,p^k)
  GLbGens := GeneratorsOfGroup(GLb);
  GLebGens := [];
  for GLbGen in GLbGens do
       Append(GLebGens, [KroneckerProduct(GLbGen, IdentityMat(q^m,GF(p^k)))]);
  od;
  embedding := GroupHomomorphismByImages(GLb, GLeb, GLbGens, GLebGens);
  CAeb := Image(embedding, GLb);
  # Construct NA as the subgroup of GL(q^m*b,p^k) generated by NCCA and CA
  NA := Subgroup(GLeb, Union(GeneratorsOfGroup(NCCAeb), GeneratorsOfGroup(CAeb)));

  # As k = 1 in all cases, GL(q^m*b*,p) = GL(q^m*b,p), we don't need to embed NA
  # and can just calculate it's normalizer directly
  N := Normalizer(GLeb, NA);
  N := Normalizer(GLeb, NCCAeb);
  # Cycle through all maximal subgroups of N, printing data about the solvable,
  # primitive ones of low rank
  possibleSubgroups := LowLayerSubgroups(N, 5, x-> (IsSolvable(x) and IsPrimitive(x)),x->(IsPrimitive(x) and Size(Orbits(Image(IsomorphismPermGroup(x)))) + 1 < 5):findall:=false);
  for G in possibleSubgroups do
    G0 := Image(IsomorphismPermGroup(G));
    rank := Size(Orbits(G0)) + 1;
    Print("Rank = ", rank, ". Order = ", Size(G), "\n");
  od;
  # while Size(possibleSubgroups) > 0 do # SLOW!!!
  #   G := possibleSubgroups[1];
  #   Print(Size(G));
  #   if IsSolvable(G) then
  #     if IsPrimitiveMatrixGroup(G) then
  #       G0 := Image(IsomorphismPermGroup(G));
  #       rank := Size(Orbits(G0)) + 1;
  #       if rank < 5 and rank > 1 then
  #         Print("Rank = ", rank, ". Order = ", Size(G), "\n");
  #       fi;
  #     fi;
  #   else
  #     Append(possibleSubgroups, LowIndexSubgroups(G, 6));
  #   fi;
  #   Remove(possibleSubgroups, 1);
  # od;
  #  for G in MaximalNormalSubgroups(N) do # SLOW!!!
  #   if IsSolvable(G) and IsPrimitiveMatrixGroup(G) then
  #     G := Image(permeb, G);
  #     rank := Size(Orbits(G)) + 1;
  #     if rank < 6 and rank > 1 then
  #       Print("Rank = ", rank, ". Order = ", Size(G), "\n", "Structure = ");
  #       Print(StructureDescription(G),"\n");
  #     fi;
  #   fi;
  # od;
od;
